<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
 - Copyright 2017, Joachim Kuebart <joachim.kuebart@gmail.com>
 -
 - Redistribution and use in source and binary forms, with or without
 - modification, are permitted provided that the following conditions are met:
 -
 -   1. Redistributions of source code must retain the above copyright
 -      notice, this list of conditions and the following disclaimer.
 -
 -   2. Redistributions in binary form must reproduce the above copyright
 -      notice, this list of conditions and the following disclaimer in the
 -      documentation and/or other materials provided with the
 -      distribution.
 -
 -   3. Neither the name of the copyright holder nor the names of its
 -      contributors may be used to endorse or promote products derived
 -      from this software without specific prior written permission.
 -
 - THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 - AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 - ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 - LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 - CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 - SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 - INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 - CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 - ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 - POSSIBILITY OF SUCH DAMAGE.
-->

<title>BerlinWalks interactive map</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.css">

<style type="text/css">
    html, body                          { height: 100%; }
    .hbox, .vbox                        { display: flex; }
    .hbox                               { flex-direction: row; }
    .vbox                               { flex-direction: column; }
    .view                               { flex-grow: 1; }

    /* Walk paths */
    .bwmap-walk {
        color: #17f; /*#17f;*/
        stroke-width: 2px;
        stroke-opacity: .8;
        transition: color .2s, stroke-width .2s;
    }
    .bwmap-walk:hover {
        stroke-width: 4px;
        stroke-opacity: 1;
    }
    .bwmap-walk.bwmap-select {
        stroke-width: 3.5px;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.1.0/gpx.min.js"></script>

<script type="text/javascript">
// Missing monadic operation
Array.prototype.flatMap = function () {
    'use strict';

    // return [].concat(f(this[0]), f(this[1]), ...)
    return Array.prototype.concat.apply([],
        Array.prototype.map.apply(this, arguments)
    );
};
</script>

<script type="text/javascript">
/*
 * Configuration for OpenStreetMap tiles.
 */
var OSM = {
    'url': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    'options': {
        'attribution':
            'Â© <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    },
};

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    /**
     * Return a Promise that resolves to the loaded JSON object on success.
     */
    function loadJson(url) {
        var xhr = new XMLHttpRequest();

        xhr.open('GET', url, true);
        xhr.responseType = 'json';

        return new Promise(function (resolve, reject) {
            xhr.onload = function () {
                if (200 === this.status) {
                    resolve(this.response);
                } else {
                    reject(new Error([url, this.status, this.statusText].join(': ')));
                }
            };
            xhr.send();
        });
    }

    var bwmap = L.map('bwmap').
        addControl(L.control.scale()).
        addLayer(L.tileLayer(OSM.url, OSM.options));

    loadJson('gpx/index.json').then(function (walks) {
        // Load GPX tracks corresponding to all the walks' dates as layers.
        walks.forEach(function (walk) {
            walk.layers = walk.dates.map(function (date) {
                return {
                    'date': new Date(date),
                    'gpx': new L.GPX('gpx/'+ date.substr(0, 10) +'.gpx', {
                        'async': true,
                        'marker_options': {
                            'endIconUrl': void 0,
                            'shadowUrl': void 0,
                            'startIconUrl': void 0,
                        },
                        'polyline_options': {
                            'className': 'bwmap-walk',
                            'color': 'currentColor',
                        },
                        'gpx_options': {
                            'parseElements': [ 'track', 'route' ],
                        },
                    }),
                };
            });
        });

        // Add a layer group containing all GPX tracks.
        bwmap.addLayer(L.layerGroup(walks.flatMap(function (walk) {
            return walk.layers.map(function (layer) { return layer.gpx; });
        })));

        // Return a Promise that fulfills when all tracks are loaded
        return Promise.all(walks.flatMap(function (walk) {
            return walk.layers.map(function (layer) {
                return new Promise(function (resolve) {
                    layer.gpx.on('loaded', function () { resolve(walk); });
                });
            });
        }));
    }).then(function (walks) {
        // Adjust the map's viewport when all GPX tracks are loaded
        var bounds = L.latLngBounds(walks.flatMap(function (walk) {
            return walk.layers.map(function (layer) {
                return layer.gpx.getBounds();
            })
        }));
        bwmap.setMaxBounds(bounds.pad(.05)).fitBounds(bounds);

        // Create a popup for all GPXs of each walk
        walks.forEach(function (walk) {
            walk.layers.forEach(function (layer) {
                var popup = document.createElement('div');
                var anchor = document.createElement('a');

                popup.textContent =
                        [ layer.date.getDate()
                        , layer.date.getMonth() + 1
                        , layer.date.getFullYear()
                        ].join('/') + ' ';
                anchor.setAttribute('href', walk.link);
                anchor.textContent = walk.title;
                popup.appendChild(anchor);
                popup.appendChild(document.createTextNode(
                    ' ' + (Math.round(layer.gpx.get_distance() / 100) / 10) + 'km'
                ));
                layer.gpx.bindPopup(popup);
            });
        });
    });
});
</script>
</head>

<body class="vbox">
  <div id="bwmap" class="view"></div>
</body>
</html>
