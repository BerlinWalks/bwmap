<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
 - Copyright 2017, Joachim Kuebart <joachim.kuebart@gmail.com>
 -
 - Redistribution and use in source and binary forms, with or without
 - modification, are permitted provided that the following conditions are met:
 -
 -   1. Redistributions of source code must retain the above copyright
 -      notice, this list of conditions and the following disclaimer.
 -
 -   2. Redistributions in binary form must reproduce the above copyright
 -      notice, this list of conditions and the following disclaimer in the
 -      documentation and/or other materials provided with the
 -      distribution.
 -
 -   3. Neither the name of the copyright holder nor the names of its
 -      contributors may be used to endorse or promote products derived
 -      from this software without specific prior written permission.
 -
 - THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 - AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 - ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 - LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 - CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 - SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 - INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 - CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 - ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 - POSSIBILITY OF SUCH DAMAGE.
-->

<meta name="viewport" content="width=device-width, initial-scale=1">

<title>BerlinWalks interactive map</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.css">

<style type="text/css">
    html, body                          { height: 100%; }
    .hbox, .vbox                        { display: flex; }
    .hbox                               { flex-direction: row; }
    .vbox                               { flex-direction: column; }
    .view                               { flex-grow: 1; }

    /* Walk paths */
    .bwmap-walk {
        color: #17f; /*#17f;*/
        stroke-width: 2px;
        stroke-opacity: .8;
        transition: color .2s, stroke-width .2s;
    }
    .bwmap-walk:hover {
        stroke-width: 4px;
        stroke-opacity: 1;
    }
    .bwmap-walk.bwmap-select {
        stroke-width: 3.5px;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.2/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.1.0/gpx.min.js"></script>

<script type="text/javascript">
// Missing monadic operation
Array.prototype.flatMap = function () {
    'use strict';

    // return [].concat(f(this[0]), f(this[1]), ...)
    return Array.prototype.concat.apply([],
        Array.prototype.map.apply(this, arguments)
    );
};
</script>

<script type="text/javascript">
var TILE_LAYERS = [];

/**
 * Configuration for OpenStreetMap tiles.
 */
TILE_LAYERS.push({
    'name': 'OSM',
    'url': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    'options': {
        'attribution':
            'Â© <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    },
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    /**
     * Return a Promise that resolves to the loaded JSON object on success.
     */
    function loadJson(url) {
        var xhr = new XMLHttpRequest();

        xhr.open('GET', url, true);
        xhr.responseType = 'json';

        return new Promise(function (resolve, reject) {
            xhr.onload = function () {
                if (200 === this.status) {
                    resolve(this.response);
                } else {
                    reject(new Error([url, this.status, this.statusText].join(': ')));
                }
            };
            xhr.send();
        });
    }

    // Create all configured tile layers.
    var tileLayers = TILE_LAYERS.map(function (layer) {
        return {
            'name': layer.name,
            'tileLayer': L.tileLayer(layer.url, layer.options),
        };
    });

    // Create layers control.
    var layersControl = L.control.layers(null, null, { 'hideSingleBase':true });
    tileLayers.forEach(function (layer) {
        layersControl.addBaseLayer(layer.tileLayer, layer.name);
    });

    // Create map with an initial tile layer and layers control.
    var bwmap = L.map('bwmap').
        addControl(L.control.scale()).
        addControl(layersControl).
        addLayer(tileLayers[0].tileLayer);

    loadJson('gpx/index.json').then(function (walks) {
        // Load GPX tracks corresponding to all the walks' dates.
        var layers = walks.flatMap(function (walk) {
            // Load GPX file for each date.
            return walk.dates.map(function (date) {
                return {
                    'date': new Date(date),
                    'walk': walk,
                    'gpx': new L.GPX('gpx/'+ date.substr(0, 10) +'.gpx', {
                        'async': true,
                        'marker_options': {
                            'endIconUrl': void 0,
                            'shadowUrl': void 0,
                            'startIconUrl': void 0,
                        },
                        'polyline_options': {
                            'className': 'bwmap-walk',
                            'color': 'currentColor',
                        },
                        'gpx_options': {
                            'parseElements': [ 'track', 'route' ],
                        },
                    }),
                };
            });
        });

        (function () {
            var yearGpx = {}, year, lg;

            // Group GPX layers by year.
            layers.forEach(function (layer) {
                var year = layer.date.getFullYear();

                if (!yearGpx[year])
                    yearGpx[year] = [];
                yearGpx[year].push(layer.gpx);
            });

            // Create one layer group per year and add to the map.
            for (year in yearGpx) if (yearGpx.hasOwnProperty(year)) {
                lg = L.layerGroup(yearGpx[year]);
                bwmap.addLayer(lg);
                layersControl.addOverlay(lg, year);
            }
        }());

        // Return a Promise that fulfills when all tracks are loaded
        return Promise.all(layers.map(function (layer) {
            return new Promise(function (resolve) {
                layer.gpx.on('loaded', function () { resolve(layer); });
            });
        }));
    }).then(function (layers) {
        // Adjust the map's viewport when all GPX tracks are loaded
        var bounds = L.latLngBounds(layers.map(function (layer) {
            return layer.gpx.getBounds();
        }));
        bwmap.setMaxBounds(bounds.pad(.05)).fitBounds(bounds);

        // Create a popup for all GPXs of each walk
        layers.forEach(function (layer) {
            var popup = document.createElement('div');
            var anchor = document.createElement('a');

            popup.textContent =
                    [ layer.date.getDate()
                    , layer.date.getMonth() + 1
                    , layer.date.getFullYear()
                    ].join('/') + ' ';
            anchor.setAttribute('href', layer.walk.link);
            anchor.textContent = layer.walk.title;
            popup.appendChild(anchor);
            popup.appendChild(document.createTextNode(
                ' ' + (Math.round(layer.gpx.get_distance() / 100) / 10) + 'km'
            ));
            layer.gpx.bindPopup(popup);
        });
    });
});
</script>
</head>

<body class="vbox">
  <div id="bwmap" class="view"></div>
</body>
</html>
